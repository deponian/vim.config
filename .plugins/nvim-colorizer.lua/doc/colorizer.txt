*colorizer*    Requires Neovim >= 0.7.0 and `set termguicolors`

Highlights terminal CSI ANSI color codes.


==============================================================================
USAGE                                                          *colorizer-usage*

 Establish the autocmd to highlight all filetypes.

      `lua require("colorizer").setup()`

Highlight using all css highlight modes in every filetype

      `lua require("colorizer").setup(user_default_options = { css = true })`

==============================================================================
USE WITH COMMANDS                                          *colorizer-commands*

  *:ColorizerAttachToBuffer*

      Attach to the current buffer and start continuously highlighting
      matched color names and codes.

      If the buffer was already attached(i.e. being highlighted), the
      settings will be reloaded. This is useful for reloading settings for
      just one buffer.

  *:ColorizerDetachFromBuffer*

      Stop highlighting the current buffer (detach).

  *:ColorizerReloadAllBuffers*

      Reload all buffers that are being highlighted currently.
      Calls ColorizerAttachToBuffer on every buffer.

  *:ColorizerToggle*
      Toggle highlighting of the current buffer.

USE WITH LUA

ATTACH
  Accepts buffer number (0 or nil for current) and an option
  table of user_default_options from `setup`.  Option table can be nil
  which defaults to setup options.

      Attach to current buffer with local options:
	  require("colorizer").attach_to_buffer(0, {
	    mode = "background",
	    css = false,
	  })

      Attach to current buffer with setup options:
	  require("colorizer").attach_to_buffer()

	  Accepts an optional buffer number (0 or nil for current).  Defaults to
	  current buffer.

DETACH

      Detach to buffer with id 22:
	  require("colorizer").attach_to_buffer(22)

      Detach from current buffer:
	  require("colorizer").detach_from_buffer(0)
	  require("colorizer").detach_from_buffer()

      Detach from buffer with id 22:
	  require("colorizer").detach_from_buffer(22)

    See:~
	|colorizer.setup|
	|colorizer.attach_to_buffer|
	|colorizer.detach_from_buffer|

==============================================================================
LUA API                                                      *colorizer-lua-api*

Functions: ~
    |highlight_buffer| - Highlight the buffer region.

    |rehighlight| - Rehighlight the buffer if colorizer is active

    |get_attached_bufnr| - Get attached bufnr

    |is_buffer_attached| - Check if buffer is attached to colorizer

    |reload_all_buffers| - Reload all of the currently active highlighted
    buffers.

    |reload_on_save| - Reload file on save; used for dev, to edit expect.txt and
    apply highlights from returned setup table

    |attach_to_buffer| - Attach to a buffer and continuously highlight changes.

    |detach_from_buffer| - Stop highlighting the current buffer.

    |setup| - Easy to use function if you want the full setup without fine
    grained control.

    |clear_highlight_cache| - Clears the highlight cache and reloads all
    buffers.


highlight_buffer()                                  *colorizer.highlight_buffer*
    Highlight the buffer region.

    See also:~
	|colorizer.buffer.highlight|




							 *colorizer.rehighlight*
rehighlight({bufnr}, {ud_opts}, {buf_local_opts}, {hl_opts})
    Rehighlight the buffer if colorizer is active

    Parameters: ~
	{bufnr} -  number: Buffer number (0 for current)
	{ud_opts} -  table: `user_default_options`
	{buf_local_opts} -  table|nil: Buffer local options
	{hl_opts} -  table|nil: Highlighting options
 - use_local_lines: boolean: Use `buf_local_opts` __startline and __endline for
   lines

    returns:~
	 table: Detach settings table to use when cleaning up buffer state in
	 `colorizer.detach_from_buffer`
 - ns_id number: Table of namespace ids to clear
 - functions function: Table of detach functions to call



get_attached_bufnr({bufnr})                       *colorizer.get_attached_bufnr*
    Get attached bufnr

    Parameters: ~
	{bufnr} -  number|nil: buffer number (0 for current)

    returns:~
	number: Returns attached bufnr. Returns -1 if buffer is not attached to
	colorizer.

    See also:~
	|colorizer.buffer.highlight|



is_buffer_attached({bufnr})                       *colorizer.is_buffer_attached*
    Check if buffer is attached to colorizer

    Parameters: ~
	{bufnr} -  number|nil: buffer number (0 for current)

    returns:~
	boolean: Returns `true` if buffer is attached to colorizer.



reload_all_buffers()                              *colorizer.reload_all_buffers*
    Reload all of the currently active highlighted buffers.



reload_on_save({pattern})                             *colorizer.reload_on_save*
    Reload file on save; used for dev, to edit expect.txt and apply highlights
    from returned setup table

    Parameters: ~
	{pattern} -  string: pattern to match file name



attach_to_buffer({bufnr}, {ud_opts}, {bo_type})     *colorizer.attach_to_buffer*
    Attach to a buffer and continuously highlight changes.

    Parameters: ~
	{bufnr} -  number|nil: buffer number (0 for current)
	{ud_opts} -  table|nil: `user_default_options`
	{bo_type} -  'buftype'|'filetype'|nil: The type of buffer option



detach_from_buffer({bufnr})                       *colorizer.detach_from_buffer*
    Stop highlighting the current buffer.

    Parameters: ~
	{bufnr} -  number|nil: buffer number (0 for current)

    returns:~
	number: returns -1 if buffer is not attached, otherwise returns bufnr



setup({opts})                                                  *colorizer.setup*
    Easy to use function if you want the full setup without fine grained
    control.

    Setup an autocmd which enables colorizing for the filetypes and options
    specified.

    By default highlights all FileTypes.

    Example config:~
>
      { filetypes = { "css", "html" }, user_default_options = { names = true } }
<
    Setup with all the default options:~
>
	require("colorizer").setup {
	  user_commands,
	  filetypes = { "*" },
	  user_default_options,
	  -- all the sub-options of filetypes apply to buftypes
	  buftypes = {},
	}
<
    Setup colorizer with user options


    Parameters: ~
	{opts} -  table|nil: User provided options

    See also:~
	|colorizer.config|

    Usage:~
	`require("colorizer").setup()`



clear_highlight_cache()                        *colorizer.clear_highlight_cache*
    Clears the highlight cache and reloads all buffers.



==============================================================================
BUFFER                                           *colorizer.buffer-introduction*

Provides highlighting functions for buffer


==============================================================================
LUA API                                               *colorizer.buffer-lua-api*

Functions: ~
    |reset_cache| - Clean the highlight cache

    |add_highlight| - Create highlight and set highlights

    |highlight| - Highlight the buffer region.

    |parse_lines| - Parse the given lines for colors and return a table
    containing
 rgb_hex and range per line


reset_cache()                                     *colorizer.buffer.reset_cache*
    Clean the highlight cache




						*colorizer.buffer.add_highlight*
add_highlight({bufnr}, {ns_id}, {line_start}, {line_end}, {data}, {ud_opts},
{hl_opts})
    Create highlight and set highlights

    Parameters: ~
	{bufnr} -  number: Buffer number (0 for current)
	{ns_id} -  number: Namespace id for which to create highlights
	{line_start} -  number: Line_start should be 0-indexed
	{line_end} -  number: Last line to highlight
	{data} -  table: Table output of `parse_lines`
	{ud_opts} -  table: `user_default_options`
	{hl_opts} -  table|nil: Highlight options:
 - tailwind_lsp boolean: Clear tailwind_names namespace when applying Tailwind
   LSP highlighting




						    *colorizer.buffer.highlight*
highlight({bufnr}, {ns_id}, {line_start}, {line_end}, {ud_opts},
{buf_local_opts})
    Highlight the buffer region.

     Highlight starting from `line_start` (0-indexed) for each line described by
     `lines` in the
     buffer id `bufnr` and attach it to the namespace id `ns_id`.


    Parameters: ~
	{bufnr} -  number: Buffer number, 0 for current
	{ns_id} -  number: Namespace id, default is "colorizer" created with
	vim.api.nvim_create_namespace
	{line_start} -  number: line_start should be 0-indexed
	{line_end} -  number: Last line to highlight
	{ud_opts} -  table: `user_default_options`
	{buf_local_opts} -  table: Buffer local options

    returns:~
	 table: Detach settings table to use when cleaning up buffer state in
	 `colorizer.detach_from_buffer`
 - ns_id number: Table of namespace ids to clear
 - functions function: Table of detach functions to call




						  *colorizer.buffer.parse_lines*
parse_lines({bufnr}, {lines}, {line_start}, {ud_opts})
    Parse the given lines for colors and return a table containing
     rgb_hex and range per line

    Parameters: ~
	{bufnr} -  number: Buffer number (0 for current)
	{lines} -  table: Table of lines to parse
	{line_start} -  number: Buffer line number to start highlighting
	{ud_opts} -  table: `user_default_options`

    returns:~
	table or nil



==============================================================================
COLOR                                             *colorizer.color-introduction*

Provides color conversion and utility functions for RGB and HSL values.


==============================================================================
LUA API                                                *colorizer.color-lua-api*

Functions: ~
    |hsl_to_rgb| - Converts an HSL color value to RGB.

    |hue_to_rgb| - Converts an HSL component to RGB, used within `hsl_to_rgb`.

    |is_bright| - Determines whether a color is bright, helping decide text
    color.


hsl_to_rgb({h}, {s}, {l})                           *colorizer.color.hsl_to_rgb*
    Converts an HSL color value to RGB.

     Accepts hue, saturation, and lightness values, each within the range [0,
     1],
     and converts them to an RGB color representation with values scaled to [0,
     255].


    Parameters: ~
	{h} -  number: Hue, in the range [0, 1].
	{s} -  number: Saturation, in the range [0, 1].
	{l} -  number: Lightness, in the range [0, 1].

    returns:~
	number or nil,number or nil,number or nil: Returns red, green, and blue
	values
	 scaled to [0, 255], or nil if any input value is out of range.
	number or nil,number or nil,number or nil



hue_to_rgb({p}, {q}, {t})                           *colorizer.color.hue_to_rgb*
    Converts an HSL component to RGB, used within `hsl_to_rgb`.

     Source: https://gist.github.com/mjackson/5311256
     This function computes one component of the RGB value by adjusting
     the color based on intermediate values `p`, `q`, and `t`.


    Parameters: ~
	{p} -  number: A helper variable representing part of the lightness
	scale.
	{q} -  number: Another helper variable based on saturation and
	lightness.
	{t} -  number: Adjusted hue component to be converted to RGB.

    returns:~
	number: The RGB component value, in the range [0, 1].



is_bright({r}, {g}, {b})                             *colorizer.color.is_bright*
    Determines whether a color is bright, helping decide text color.

     ref: https://stackoverflow.com/a/1855903/837964
     https://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color
     Calculates the perceived luminance of the RGB color. Returns `true` if
     the color is bright enough to warrant black text and `false` otherwise.
     Formula based on the human eye’s sensitivity to different colors.


    Parameters: ~
	{r} -  number: Red component, in the range [0, 255].
	{g} -  number: Green component, in the range [0, 255].
	{b} -  number: Blue component, in the range [0, 255].

    returns:~
	boolean: `true` if the color is bright, `false` if it's dark.



==============================================================================
CONFIG                                           *colorizer.config-introduction*

Provides configuration options and utilities for setting up colorizer.


==============================================================================
LUA API                                               *colorizer.config-lua-api*

Functions: ~
    |set_bo_value| - Set options for a specific buffer or file type.

    |apply_alias_options| - Parse and apply alias options to the user options.

    |get_setup_options| - Initializes colorizer with user-provided options.

    |new_bo_options| - Retrieve buffer-specific options or user_default_options
    defined when setup() was called.

    |get_bo_options| - Retrieve options based on buffer type and file type.

Tables: ~
    |user_default_options| - Default user options for colorizer.

    |options| - Options for colorizer that were passed in to setup function

    |ud_opts| - Configuration options for the `setup` function.


set_bo_value({bo_type}, {val}, {ud_opts})        *colorizer.config.set_bo_value*
    Set options for a specific buffer or file type.

    Parameters: ~
	{bo_type} -  'buftype'|'filetype': The type of buffer option
	{val} -  string: The specific value to set.
	{ud_opts} -  table: `user_default_options`



apply_alias_options({ud_opts})            *colorizer.config.apply_alias_options*
    Parse and apply alias options to the user options.

    Parameters: ~
	{ud_opts} -  table: user_default_options

    returns:~
	table



get_setup_options({opts})                   *colorizer.config.get_setup_options*
    Initializes colorizer with user-provided options.

     Merges default settings with any user-specified options, setting up
     `filetypes`,
     `user_default_options`, and `user_commands`.


    Parameters: ~
	{opts} -  table|nil: Configuration options for colorizer.

    returns:~
	table: Final settings after merging user and default options.



new_bo_options({bufnr}, {bo_type})             *colorizer.config.new_bo_options*
    Retrieve buffer-specific options or user_default_options defined when
    setup() was called.

    Parameters: ~
	{bufnr} -  number: The buffer number.
	{bo_type} -  'buftype'|'filetype': The type of buffer option




					       *colorizer.config.get_bo_options*
get_bo_options({bo_type}, {buftype}, {filetype})
    Retrieve options based on buffer type and file type.
      Prefer filetype.


    Parameters: ~
	{bo_type} -  'buftype'|'filetype': The type of buffer option
	{buftype} -  string: Buffer type.
	{filetype} -  string: File type.

    returns:~
	table



user_default_options                     *colorizer.config.user_default_options*
    Default user options for colorizer.

    This table defines individual options and alias options, allowing
    configuration of
    colorizer's behavior for different color formats (e.g., `#RGB`, `#RRGGBB`,
    `#AARRGGBB`, etc.).

    Individual Options: Options like `names`, `RGB`, `RRGGBB`, `RRGGBBAA`,
    `hsl_fn`, `rgb_fn`,
    `AARRGGBB`, `tailwind`, and `sass` can be enabled or disabled independently.

    Alias Options: `css` and `css_fn` enable multiple options at once.
      - `css_fn = true` enables `hsl_fn` and `rgb_fn`.
      - `css = true` enables `names`, `RGB`, `RRGGBB`, `RRGGBBAA`, `hsl_fn`, and
	`rgb_fn`.

    Option Priority: Individual options have higher priority than aliases.
    If both `css` and `css_fn` are true, `css_fn` has more priority over `css`.


    Fields: ~
	{names} -  boolean: Enables named colors (e.g., "Blue").
	{names_opts} -  table: Names options for customizing casing, digit
	stripping, etc
	{names_custom} -  table|function|false: Custom color name to RGB value
	mappings
 should return a table of color names to RGB value pairs
	{RGB} -  boolean: Enables `#RGB` hex codes.
	{RGBA} -  boolean: Enables `#RGBA` hex codes.
	{RRGGBB} -  boolean: Enables `#RRGGBB` hex codes.
	{RRGGBBAA} -  boolean: Enables `#RRGGBBAA` hex codes.
	{AARRGGBB} -  boolean: Enables `0xAARRGGBB` hex codes.
	{rgb_fn} -  boolean: Enables CSS `rgb()` and `rgba()` functions.
	{hsl_fn} -  boolean: Enables CSS `hsl()` and `hsla()` functions.
	{css} -  boolean: Enables all CSS features (`rgb_fn`, `hsl_fn`, `names`,
	`RGB`, `RRGGBB`).
	{css_fn} -  boolean: Enables all CSS functions (`rgb_fn`, `hsl_fn`).
	{tailwind} -  boolean|string: Enables Tailwind CSS colors (e.g.,
	`"normal"`, `"lsp"`, `"both"`).
	{tailwind_opts} -  table: Tailwind options for updating names cache, etc
	{sass} -  table: Sass color configuration (`enable` flag and `parsers`).
	{mode} -  'background'|'foreground'|'virtualtext': Display mode
	{virtualtext} -  string: Character used for virtual text display.
	{virtualtext_inline} -  boolean|'before'|'after': Shows virtual text
	inline with color.
	{virtualtext_mode} -  'background'|'foreground': Mode for virtual text
	display.
	{always_update} -  boolean: Always update color values, even if buffer
	is not focused.
	hooks -  table: Table of hook functions
	{disable_line_highlight} -  function: Returns boolean which controls if
	line should be parsed for highlights



options                                               *colorizer.config.options*
    Options for colorizer that were passed in to setup function

    Fields: ~
	{filetypes} -
	{buftypes} -
	{user_commands} -
	{lazy_load} -
	{user_default_options} -
	{exclusions} -
	{all} -



ud_opts                                               *colorizer.config.ud_opts*
    Configuration options for the `setup` function.

    Fields: ~
	{filetypes} -  (table|nil): Optional.  A list of file types where
	colorizer should be enabled. Use `"*"` for all file types.
	{user_default_options} -  table: Default options for color handling.
 >
   - `names` (boolean): Enables named color codes like `"Blue"`.
   - `names_opts` (table): Names options for customizing casing, digit
     stripping, etc
     - `lowercase` (boolean): Converts color names to lowercase.
     - `camelcase` (boolean): Converts color names to camelCase.  This is the
       default naming scheme for colors returned from
       `vim.api.nvim_get_color_map`
     - `uppercase` (boolean): Converts color names to uppercase.
     - `strip_digits` (boolean): Removes digits from color names.
   - `names_custom` (table|function|false): Custom color name to RGB value
     mappings
   - `RGB` (boolean): Enables support for `#RGB` hex codes.
   - `RGBA` (boolean): Enables support for `#RGBA` hex codes.
   - `RRGGBB` (boolean): Enables support for `#RRGGBB` hex codes.
   - `RRGGBBAA` (boolean): Enables support for `#RRGGBBAA` hex codes.
   - `AARRGGBB` (boolean): Enables support for `0xAARRGGBB` hex codes.
   - `rgb_fn` (boolean): Enables CSS `rgb()` and `rgba()` functions.
   - `hsl_fn` (boolean): Enables CSS `hsl()` and `hsla()` functions.
   - `css` (boolean): Enables all CSS-related features (e.g., `names`, `RGB`,
     `RRGGBB`, `hsl_fn`, `rgb_fn`).
   - `css_fn` (boolean): Enables all CSS function-related features (e.g.,
     `rgb_fn`, `hsl_fn`).
   - `tailwind` (boolean|string): Enables Tailwind CSS colors. Accepts `true`,
     `"normal"`, `"lsp"`, or `"both"`.
   - `tailwind_opts` (table): Tailwind options for updating names cache, etc
      - `update_names` (boolean): Updates Tailwind "normal" names cache from LSP
	results.  This provides a smoother highlighting experience when tailwind
	= "both" is used.  Highlighting on non-tailwind lsp buffers (like cmp)
	becomes more consistent.
   - `sass` (table): Configures Sass color support.
      - `enable` (boolean): Enables Sass color parsing.
      - `parsers` (table): A list of parsers to use, typically includes `"css"`.
   - `mode` (string): Determines the display mode for highlights. Options are
     `"background"`, `"foreground"`, and `"virtualtext"`.
   - `virtualtext` (string): Character used for virtual text display of colors
     (default is `"■"`).
  - `virtualtext_inline` (boolean|'before'|'after'): Shows the virtual text
    inline with the color.  True defaults to 'before'.
  - `virtualtext_mode` ('background'|'foreground'): Determines the display mode
    for virtual text.
  - `always_update` (boolean): If true, updates color values even if the buffer
    is not focused.<
 - `hooks` (table): Table of hook functions
    - `disable_line_highlight` (function): Returns a boolean that controls if
      the line should be parsed for highlights. Called  with 3 parameters:
      - `line` (string): The line's contents.
      - `bufnr` (number): The buffer number.
      - `line_num` (number): The line number (0-indexed).  Add 1 to get the line
	number in the buffer.
	{buftypes} -  (table|nil): Optional. A list of buffer types where
	colorizer should be enabled. Defaults to all buffer types if not
	provided.
	{user_commands} -  (boolean|table): If true, enables all user commands
	for colorizer. If `false`, disables user commands. Alternatively,
	provide a table of specific commands to enable:
   - `"ColorizerAttachToBuffer"`
   - `"ColorizerDetachFromBuffer"`
   - `"ColorizerReloadAllBuffers"`
   - `"ColorizerToggle"`
	{lazy_load} -  (boolean): If true, lazily schedule buffer highlighting
	setup function



==============================================================================
CONSTANTS                                     *colorizer.constants-introduction*

This module provides constants that are required across the application


==============================================================================
LUA API                                            *colorizer.constants-lua-api*

Tables: ~
    |plugin| - Plugin name

    |namespace| - Namespaces used for colorizing
 - default - Default namespace
 - tailwind - Namespace used for creating extmarks to prevent tailwind name
   parsing from overwriting tailwind lsp highlights

    |autocmd| - Autocommand group for setting up Colorizer

    |highlight_mode_names| - Highlight mode names.

    |defaults| - Miscellaneous constants


plugin                                              *colorizer.constants.plugin*
    Plugin name

    Fields: ~
	{name} -



namespace                                        *colorizer.constants.namespace*
    Namespaces used for colorizing
     - default - Default namespace
     - tailwind - Namespace used for creating extmarks to prevent tailwind name
       parsing from overwriting tailwind lsp highlights

    Fields: ~
	{default} -
	{tailwind_lsp} -



autocmd                                            *colorizer.constants.autocmd*
    Autocommand group for setting up Colorizer

    Fields: ~
	{setup} -
	{bo_type_ac} -
	{buftype} -



highlight_mode_names                  *colorizer.constants.highlight_mode_names*
    Highlight mode names.
      Used to create highlight names to be used with
      vim.api.nvim_buf_add_highlight
     - background - Background mode
     - foreground - Foreground mode
     - virtualtext - Virtual text mode


    Fields: ~
	{background} -
	{foreground} -
	{virtualtext} -



defaults                                          *colorizer.constants.defaults*
    Miscellaneous constants

    Fields: ~
	{virtualtext} -



==============================================================================
MATCHER                                         *colorizer.matcher-introduction*

Manages matching and parsing of color patterns in buffers.

This module provides functions for setting up and applying color parsers
for different color formats such as RGB, HSL, hexadecimal, and named colors.
It uses a trie-based structure to optimize prefix-based parsing.

==============================================================================
LUA API                                              *colorizer.matcher-lua-api*

Functions: ~
    |reset_cache| - Reset matcher cache
 Called from colorizer.setup

    |make| - Parse the given options and return a function with enabled parsers.


reset_cache()                                    *colorizer.matcher.reset_cache*
    Reset matcher cache
     Called from colorizer.setup



make({ud_opts})                                         *colorizer.matcher.make*
    Parse the given options and return a function with enabled parsers.

    if no parsers enabled then return false
    Do not try make the function again if it is present in the cache


    Parameters: ~
	{ud_opts} -  table: options created in `colorizer.setup`

    returns:~
	function or boolean: function which will just parse the line for enabled
	parsers



==============================================================================
HSL                                          *colorizer.parser.hsl-introduction*

This module provides a parser for identifying and converting `hsl()` and
`hsla()` CSS functions to RGB hexadecimal format.

It supports various CSS color value formats, including degrees (`deg`), turns
(`turn`), percentages, and alpha transparency.
This function is useful for syntax highlighting or color recognition in a text
editor.

==============================================================================
LUA API                                           *colorizer.parser.hsl-lua-api*

Functions: ~
    |parser| - Parses `hsl()` and `hsla()` CSS functions and converts them to
    RGB hexadecimal format.


parser({line}, {i}, {opts})                        *colorizer.parser.hsl.parser*
    Parses `hsl()` and `hsla()` CSS functions and converts them to RGB
    hexadecimal format.

     This function matches `hsl()` or `hsla()` functions within a line of text,
     extracting and converting the hue, saturation, and luminance
     to an RGB color. It handles angles in degrees and turns, percentages, and
     an optional alpha (transparency) value.


    Parameters: ~
	{line} -  string: The line of text to parse
	{i} -  number: The starting index within the line where parsing should
	begin
	{opts} -  table: Parsing options, including:
  - `prefix` (string): "hsl" or "hsla" to specify the CSS function type.

    returns:~
	number or nil: The end index of the parsed `hsl/hsla` function within
	the line, or `nil` if no match was found.
	string or nil: The RGB hexadecimal color (e.g., "ff0000" for red), or
	`nil` if parsing failed



==============================================================================
NAMES                                      *colorizer.parser.names-introduction*

This module provides a parser that identifies named colors from a given line of
text.

It uses a Trie structure for efficient prefix-based matching of color names to
#rrggbb values.
The module supports multiple namespaces, enabling flexible configuration and
handling of
different types of color names (e.g., lowercase, uppercase, camelcase, custom
names, Tailwind names).

Namespaces:
>
- lowercase: Contains color names converted to lowercase (e.g., "red" ->
  "#ff0000").
- uppercase: Contains color names converted to uppercase (e.g., "RED" ->
  "#ff0000").
- camelcase: Contains color names in camel case (e.g., "LightBlue" ->
  "#add8e6").
- tailwind_names: Contains color names based on TailwindCSS conventions,
  including prefixes.
- names_custom: Contains user-defined color names, either as a table or a
  function returning a table.<

The parser dynamically populates the Trie and namespaces based on the provided
options.
Unused namespaces are left empty, avoiding unnecessary memory usage. Color name
matching respects
the configured namespaces and user-defined preferences, such as whether to strip
digits.

==============================================================================
LUA API                                         *colorizer.parser.names-lua-api*

Functions: ~
    |reset_cache| - Reset the color names cache.

    |update_color| - Updates the color value for a given color name.

    |parser| - Parses a line to identify color names.


reset_cache()                               *colorizer.parser.names.reset_cache*
    Reset the color names cache.

     Called from colorizer.setup




update_color({name}, {hex}, {namespace})   *colorizer.parser.names.update_color*
    Updates the color value for a given color name.

    Parameters: ~
	{name} -  string: The color name.
	{hex} -  string: The color value in hex format.
	{namespace} -  string: The color map namespace.



parser({line}, {i}, {m_opts})                    *colorizer.parser.names.parser*
    Parses a line to identify color names.

    Parameters: ~
	{line} -  string: The text line to parse.
	{i} -  number: The index to start parsing from.
	{m_opts} -  table: Matcher opts

    returns:~
	number or nil, string or nil: Length of match and hex value if found.



==============================================================================
RGBA_HEX                                *colorizer.parser.rgba_hex-introduction*

This module provides a parser for identifying and converting `#RRGGBBAA`
hexadecimal color values to RGB hexadecimal format.

It is commonly used in Android apps for colors with an alpha (transparency)
component.
The function reads the color, applies the alpha to each RGB channel, and returns
the resulting RGB hex string.

==============================================================================
LUA API                                      *colorizer.parser.rgba_hex-lua-api*

Functions: ~
    |parser| - Parses `#RRGGBBAA` hexadecimal colors and converts them to RGB
    hex format.


parser({line}, {i}, {opts})                   *colorizer.parser.rgba_hex.parser*
    Parses `#RRGGBBAA` hexadecimal colors and converts them to RGB hex format.

     This function matches `#RRGGBBAA` format colors within a line, handling
     alpha transparency if specified.
     It checks the length of the color string to match expected valid lengths
     (e.g., 4, 7, 9 characters).


    Parameters: ~
	{line} -  string: The line of text to parse for the hex color
	{i} -  number: The starting index within the line where parsing should
	begin
	{opts} -  table: Options containing:
 - `minlen` (number): Minimum length of the color string
 - `maxlen` (number): Maximum length of the color string
 - `valid_lengths` (table): Set of valid lengths (e.g., `{3, 4, 6, 8}`)

    returns:~
	number or nil: The end index of the parsed hex color within the line, or
	`nil` if parsing failed
	string or nil: The RGB hexadecimal color (e.g., "ff0000" for red), or
	`nil` if parsing failed



==============================================================================
RGB_HEX                                  *colorizer.parser.rgb_hex-introduction*

This module provides a parser for extracting `0xAARRGGBB` hexadecimal color
values and converting them to RGB hex.

This format is commonly used in Android apps for color values, where the color
includes an alpha (transparency) component.
The function parses the color, applies the alpha value to each RGB channel, and
returns the resulting RGB hex string.

==============================================================================
LUA API                                       *colorizer.parser.rgb_hex-lua-api*

Functions: ~
    |parser| - Parses a `0xAARRGGBB` formatted hexadecimal color and converts it
    to an RGB hex value.


parser({line}, {i})                            *colorizer.parser.rgb_hex.parser*
    Parses a `0xAARRGGBB` formatted hexadecimal color and converts it to an RGB
    hex value.

     This function reads a color from a line of text, expecting it in the
     `0xAARRGGBB` format (common in Android apps).
     It extracts the alpha (AA), red (RR), green (GG), and blue (BB) components,
     applies the alpha to the RGB channels, and outputs
     the resulting RGB color in hexadecimal format.


    Parameters: ~
	{line} -  string: The line of text to parse
	{i} -  number: The starting index within the line where parsing should
	begin

    returns:~
	number or nil: The end index of the parsed hex value within the line, or
	`nil` if parsing failed
	string or nil: The RGB hexadecimal color (e.g., "ff0000" for red), or
	`nil` if parsing failed



==============================================================================
RGB                                          *colorizer.parser.rgb-introduction*

This module provides a parser for identifying and converting `rgb()` and
`rgba()` CSS functions to RGB hexadecimal format.

It supports decimal and percentage values for RGB channels, as well as an
optional alpha (transparency) component.
The function can interpret a variety of CSS syntax variations, making it useful
for syntax highlighting or color parsing.

==============================================================================
LUA API                                           *colorizer.parser.rgb-lua-api*

Functions: ~
    |parser| - Parses `rgb()` and `rgba()` CSS functions and converts them to
    RGB hexadecimal format.


parser({line}, {i}, {opts})                        *colorizer.parser.rgb.parser*
    Parses `rgb()` and `rgba()` CSS functions and converts them to RGB
    hexadecimal format.

     This function matches `rgb()` or `rgba()` functions in a line of text,
     extracting RGB and optional alpha values.
     It supports decimal and percentage formats, alpha transparency, and comma
     or space-separated CSS syntax.


    Parameters: ~
	{line} -  string: The line of text to parse for the color function
	{i} -  number: The starting index within the line where parsing should
	begin
	{opts} -  table: Parsing options, including:
  - `prefix` (string): "rgb" or "rgba" to specify the CSS function type

    returns:~
	number or nil: The end index of the parsed `rgb/rgba` function within
	the line, or `nil` if parsing failed
	string or nil: The RGB hexadecimal color (e.g., "ff0000" for red), or
	`nil` if parsing failed



==============================================================================
SASS                                               *colorizer.sass-introduction*

Manages Sass variable parsing and color detection for buffers.

This module handles the parsing of Sass color variables, managing import
statements,
and watching files for updates to Sass variable definitions.
It supports recursive Sass imports, resolving color values for each variable,
and caching color definitions.

==============================================================================
LUA API                                                 *colorizer.sass-lua-api*

Functions: ~
    |cleanup| - Cleanup sass variables and watch handlers

    |parser| - Parse the given line for sass color names
 check for value in state[buf].definitions_all

    |update_variables| - Parse the given lines for sass variabled and add to
    `sass_state[buf].definitions_all`.


cleanup({bufnr})                                        *colorizer.sass.cleanup*
    Cleanup sass variables and watch handlers

    Parameters: ~
	{bufnr} -  number



parser({line}, {i}, {bufnr})                             *colorizer.sass.parser*
    Parse the given line for sass color names
     check for value in state[buf].definitions_all

    Parameters: ~
	{line} -  string: Line to parse
	{i} -  number: Index of line from where to start parsing
	{bufnr} -  number: Buffer number

    returns:~
	number or nil, string or nil




					       *colorizer.sass.update_variables*
update_variables({bufnr}, {line_start}, {line_end}, {lines}, {color_parser},
{ud_opts}, {buf_local_opts})
    Parse the given lines for sass variabled and add to
    `sass_state[buf].definitions_all`.

     which is then used in |sass_name_parser|
     If lines are not given, then fetch the lines with line_start and line_end


    Parameters: ~
	{bufnr} -  number: Buffer number
	{line_start} -  number
	{line_end} -  number
	{lines} -  table|nil
	{color_parser} -  function|boolean
	{ud_opts} -  table: `user_default_options`
	{buf_local_opts} -  table|nil: Buffer local options



==============================================================================
TAILWIND                                       *colorizer.tailwind-introduction*

Handles Tailwind CSS color highlighting within buffers.

This module integrates with the Tailwind CSS Language Server Protocol (LSP) to
retrieve and apply
color highlights for Tailwind classes in a buffer. It manages LSP attachment,
autocmds for color updates,
and maintains state for efficient Tailwind highlighting.

==============================================================================
LUA API                                             *colorizer.tailwind-lua-api*

Functions: ~
    |cleanup| - Cleanup tailwind variables and autocmd

    |lsp_highlight| - Highlight buffer using values returned by tailwindcss


cleanup({bufnr})                                    *colorizer.tailwind.cleanup*
    Cleanup tailwind variables and autocmd

    Parameters: ~
	{bufnr} -  number|nil: buffer number (0 for current)




					      *colorizer.tailwind.lsp_highlight*
lsp_highlight({bufnr}, {ud_opts}, {buf_local_opts}, {add_highlight},
{on_detach}, {line_start}, {line_end})
    Highlight buffer using values returned by tailwindcss

    Parameters: ~
	{bufnr} -  number: Buffer number (0 for current)
	{ud_opts} -  table: `user_default_options`
	{buf_local_opts} -  table: Buffer local options
	{add_highlight} -  function: Function to add highlights
	{on_detach} -  function: Function to call when LSP is detached
	{line_start} -  number: Start line
	{line_end} -  number: End line

    returns:~
	boolean or nil



==============================================================================
USERCMDS                                       *colorizer.usercmds-introduction*

This module provides functions for creating user commands for the Colorizer
plugin in Neovim.

It allows the creation of commands to attach, detach, reload, and toggle the
Colorizer functionality on buffers.
Available commands are:
>
- `ColorizerAttachToBuffer`: Attaches Colorizer to the current buffer
- `ColorizerDetachFromBuffer`: Detaches Colorizer from the current buffer
- `ColorizerReloadAllBuffers`: Reloads Colorizer for all buffers
- `ColorizerToggle`: Toggles Colorizer attachment to the buffer <

==============================================================================
LUA API                                             *colorizer.usercmds-lua-api*

Functions: ~
    |make| - Create user commands for Colorizer based on the given command list.


make({cmds})                                           *colorizer.usercmds.make*
    Create user commands for Colorizer based on the given command list.

     This function defines and registers Colorizer commands based on the
     provided list.


    Parameters: ~
	{cmds} -  table|boolean A list of command names to create or `true` to
	create all available commands



==============================================================================
UTILS                                             *colorizer.utils-introduction*

Provides utility functions for color handling and file operations.

This module contains helper functions for checking byte categories, merging
tables,
parsing colors, managing file watchers, and handling buffer lines.

==============================================================================
LUA API                                                *colorizer.utils-lua-api*

Functions: ~
    |rgb_to_hex| - Returns HEX format from RGB values

    |byte_is_alphanumeric| - Checks if a byte represents an alphanumeric
    character.

    |byte_is_hex| - Checks if a byte represents a hexadecimal character.

    |get_non_alphanum_keys| - Extract non-alphanumeric characters to add as a
    valid index in the Trie

    |add_additional_color_chars| - Adds additional characters to the list of
    valid color characters.

    |byte_is_valid_color_char| - Checks if a byte is valid as a color character
    (alphanumeric, dynamically added chars, or hardcoded characters).

    |count| - Count the number of character in a string

    |get_last_modified| - Get last modified time of a file

    |parse_hex| - Parses a hexadecimal byte.

    |watch_file| - Watch a file for changes and execute callback

    |bufme| - Validates and returns a buffer number.

    |visible_line_range| - Returns range of visible lines

    |hash_table| - Returns sha256 hash of lua table


rgb_to_hex({r}, {g}, {b})                           *colorizer.utils.rgb_to_hex*
    Returns HEX format from RGB values

    Parameters: ~
	{r} -  number: Red value
	{g} -  number: Green value
	{b} -  number: Blue value



byte_is_alphanumeric({byte})              *colorizer.utils.byte_is_alphanumeric*
    Checks if a byte represents an alphanumeric character.

    Parameters: ~
	{byte} -  number The byte to check.

    returns:~
	boolean: `true` if the byte is alphanumeric, otherwise `false`.



byte_is_hex({byte})                                *colorizer.utils.byte_is_hex*
    Checks if a byte represents a hexadecimal character.

    Parameters: ~
	{byte} -  number The byte to check.

    returns:~
	boolean: `true` if the byte is hexadecimal, otherwise `false`.



get_non_alphanum_keys({tbl})             *colorizer.utils.get_non_alphanum_keys*
    Extract non-alphanumeric characters to add as a valid index in the Trie

    Parameters: ~
	{tbl} -  table: The table to extract non-alphanumeric characters from.

    returns:~
	string: The extracted non-alphanumeric characters.



add_additional_color_chars({chars}) *colorizer.utils.add_additional_color_chars*
    Adds additional characters to the list of valid color characters.

    Parameters: ~
	{chars} -  string: The additional characters to add.

    returns:~
	boolean: `true` if the characters were added, otherwise `false`.



byte_is_valid_color_char({byte})      *colorizer.utils.byte_is_valid_color_char*
    Checks if a byte is valid as a color character (alphanumeric, dynamically
    added chars, or hardcoded characters).

    Parameters: ~
	{byte} -  number: The byte to check.

    returns:~
	boolean: `true` if the byte is valid, otherwise `false`.



count({str}, {pattern})                                  *colorizer.utils.count*
    Count the number of character in a string

    Parameters: ~
	{str} -  string
	{pattern} -  string

    returns:~
	number



get_last_modified({path})                    *colorizer.utils.get_last_modified*
    Get last modified time of a file

    Parameters: ~
	{path} -  string: file path

    returns:~
	number or nil: modified time



parse_hex({byte})                                    *colorizer.utils.parse_hex*
    Parses a hexadecimal byte.

    Parameters: ~
	{byte} -  number The byte to parse.

    returns:~
	number: The parsed hexadecimal value of the byte.



watch_file({path}, {callback}, {...})               *colorizer.utils.watch_file*
    Watch a file for changes and execute callback

    Parameters: ~
	{path} -  string: File path
	{callback} -  function: Callback to execute
	{...} -  table: params for callback

    returns:~
	uv_fs_event_t or nil



bufme({bufnr})                                           *colorizer.utils.bufme*
    Validates and returns a buffer number.

     If the provided buffer number is invalid, defaults to the current buffer.


    Parameters: ~
	{bufnr} -  number|nil: The buffer number to validate.

    returns:~
	number: The validated buffer number.



visible_line_range({bufnr})                 *colorizer.utils.visible_line_range*
    Returns range of visible lines

    Parameters: ~
	{bufnr} -  number: Buffer number

    returns:~
	number, number: Start (0-index) and end (exclusive) range of lines in
	viewport



hash_table({tbl})                                   *colorizer.utils.hash_table*
    Returns sha256 hash of lua table

    Parameters: ~
	{tbl} -  table: Table to be hashed



vim:tw=80:ts=8:noet:ft=help:norl:
